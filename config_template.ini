[defaults]
# The two values in this section will be applied to the sections named in the sources section below. Default values will
# be overwritten by values of the same name in those sections
header_row_num = 0
ignored_rows = -1

[sources]
# Specify source names and the path (absolute or relative) to the corresponding csv in this section. Add a section for
# that source below by the same name you put here. Fill out values for target_column(s), header_row_num, ignored_rows, &
# match by. Sources are prioritized in the order you put them below (first is highest priority). Higher priority sources
# are parsed first, added to the output first, and if --strict is used, the first source is used to match successive
# sources. If data from two different sources collides (two values for same row, column), the higher priority source is
# used.
# Ex:
# source_name = /path/to/csv

# Ex continued:
[source_name]
target_column(s) = field5,field9
# Optionally give new names for target column(s) to assume in the output (matches based on order)
# If there are differing numbers of column names vs target columns, then column names are used in the order they are
# given and matched to corresponding target columns until either one runs out. If column names run out first, then
# remaining target columns will not be given a new name. If target columns run out first, then the excess column names
# are not used.
column_name(s) = new name for field5,name for field9,excess names don't get used
header_row_num =
ignored_rows =
match_by = field1,field2,etc

# defaults do not apply to sections below here
# ==============================================
[output]
file_name = output.csv
# unmatched data is only put into a file if you give a file name below
unmatched_file_name =
# valid dialects: unix, excel, excel_tab
dialect = excel

[source_rules]
# what is valid for what source and what is missing from some sources that appear in others?

[field_rules]
# Field validation:
# This section is entirely optional.
#
# Enter field names (headers) and then on the other side of the equal sign put a regular expression for data to be
# validated by. Do not wrap your regular expression in /. Data in the column of the given header that does not match the
# given regular expression will not be transferred.
# Ex:
# IPv4 address = ^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$